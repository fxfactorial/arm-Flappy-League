\documentclass[11pt]{article}

\usepackage{fullpage}

\begin{document}

\title{Flappy League Report}
\author{Benjamin Gunton, Harjuno Perwironegoro, Nimesh Subedi, Szymon Zmyslony}

\maketitle
\section{Assembler}
\subsection{Structure}
 We decided to divide the task in a way proposed in the specification. We chose to implement two passes in assembly as we thought it would less bug prone. Secondly, we created a tokeniser that would seperate the opcode and opFields in a given line of text. Then, we just implemented encoding of each type of instruction separately. Having learnt about reusing the code in the emulator part, we also used a lot of helper functions that would be common to all encode functions (changing the endianess, getting register number from the instruction for Rn, getting and setting certain bytes), some of which had themselves been used in the emulator. Our data structure for mapping labels to memory adresses was a generic implemententation of a linked list. 
\subsection{Implementation}
As using function pointers in the emulator turned out to be a neat way of choosing the correct function to use, we reused that idea creating a table that mapped names of functions (strings) to appropriate pointers. Another major point in our implementation is using macros for encoding instructions that differ by only a few bits. For example, we created a macro that takes the name of a function and a condition and encodes all branching instructions that differ only by condition bits (four bits). Not only did it make our code more succinct, but also simplified finding bugs and fixing them.
\section{Extension - What and why?}
All of us have been inspired and amazed by the enjoyment that a 2-button game with simple graphics can bring. With the C project At the same time, we wanted our extension to both teach us further concepts in C (extensive use of different libraries) and be interesting to implement. Thus, we decided to create a two player game inspired by the famous Flappy Bird. Each player controls one bird with two buttons (left, right) and tries to score a goal. The game is time limited and comes with sound effects, a board that dispay the score, and a menu to choose your character.
\section{Design}
Initially, we had a naive design approach. We started by building ideas for a simple one-button game, thinking it was an attainable goal without knowledge of any libraries. We first looked into directly accessing the console framebuffer using various online tutorials. The performance issues caused us to momentarily give up the idea of a high-quality game.
However, we managed to find about the SDL library. SDL is a library (primarily used with C++, but written in C) that provides an interface for rendering images, playing audio, and processing input from the keyboard. It proved to be incredibly useful, reducing the complexity introduced by having to directly access IO. It also allowed us to focus on using C to create a game, which was already challenging due to it not being an Object-Oriented language. At this point we changed our game idea, with relatively simple mechanics.
We wanted to integrate the game with the Pi, and thought of using buttons on a breadboard as controllers. In order to get low-level input from our buttons, we had to be able to read the voltage at GPIOs using C. We achieved this through installing the wiringPI library on our PI. We settled on a two-button game after this success.
To an extent, we simulated using objects using structs and unions. The GameObject struct we created became the base making all objects, taking some inspiration from ECS (Entity Component Systems). However, the use of unions eliminated a lot of type checking, so we had to be very careful. Our design of the struct was effective, but could be improved by using list ADTs.
The gameplay design was simple - quirky, yet easy to understand, controls and the concept of football makes the game easily accessible but still fun to play. We used elastic collision, basic air resistance and gravity for the game's physics.
The mood the game creates is largely dominated by the auditory and visual senses. We used various ambient stadium sounds (under the Creative Commons license) to keep the game competitive despite the quirky controls, but also kept it lighthearted with the bird character design.

\section{Testing}
The final game has been tested on the PI and worked quite smootly; however, major parts of testings have occured before it. We developed componenets of the project seperately and tested them so. Input buttons were tested using simple print messages directly on the pi. The physics engine was tested numerically using assertions and print statements. All the behaviour of the objects inside the game was tested with the use of debugDraw function that drew hit boxes hidden behind images. Before transferring the game onto the Pi, we successfully ran it in on a Linux machine as it was easier to manipulate the code using IDE's and other more advanced tools. We believe that testing separate components was a very efficient way of making sure that our final product will work. 

\section{Group reflection}
\subsection{How did we do?}
It is our shared opinion that we have done very well as a group. Reading and discussing the spec thoroughly during the first day of the project has proven to be very beneficial for us as it developed a deeper understanding of the problem (which was triggered by all of us asking questions and making eachother think). The formula in which half of the group debugs one part and the other half moves on to the next part was quite efficient and we do not plan to change this in further projects. It allowed us to solve problems without getting in eachother's way, while keeping the project moving forward. At the end of the day, we have benefited the most from the group chat on Facebook which provided us with means to discuss our individual programming challenges on the go as well as coordinate our group tasks very dynamically. 
\subsection{How can we improve?}
The major area of improvement is splitting the work between group members. As some parts of assembly and emulator (such as decoding Data Processing instructions) were much longer and harder than others, our initial plan had to be modified. It did not lead to a major downtime, but we still could have been more efficient had we thought about it at the beginning. Also, we feel that our extension could have been better, had we started to develop it earlier. Thus, in future, we plan on finishing the compulsory work earlier so we would get more time for improving our final project.
\section{Individual reflections}

\subsection{Ben}
This project has been a learning experience for me. While I have worked in groups in the past I found working on the same project in this way, with everyone working closely on the same files, to be something new. At first I thought this would be a challenge but I feel that our group handled the project well. In particular I think that the time spent at the start of each task, where we divided up the workload, was well spent and really helped us to know what needed doing. In my opinion the earlier tasks were easier to divide up than the later tasks, and towards the end of the project more group work was required with everyone working at the same time, and communicating issues as they arose. I feel like we have worked well as a team in this respect, as communication has always been good, and everyone has worked hard to complete all the tasks.
\subsection{Uno}
From the feedback of my group members, I know that I have worked very cooperatively and contributed well in the team. One major improvement that I have realised is that I could have spread the workload much more efficiently during the extension. As I did the majority of the research into the libraries, and had more experience with games, I took charge of implementing the game. Whilst I did designate modular tasks, such as implementing the physics engine and IO control, to other team members, I should have taken some time to explain the implementation details. This would have enabled them to come up potentially better solutions, regulate my code, and share some of the work when my speed was a limiting factor. I have learned that, in addition to good communication and planning, you need to be willing to ask for help when necessary to work as an optimal team.
\subsection{Nimesh}
Ranging from coordination to communication, I feel that this project has helped me polish my skills required in group projects. The webPA feedback from my team not only validates this, but also conveys that the others had the pleasure to work with me. Initially, I was overwhelmed by the specification of the project and had no idea where to start, like everyone else in the team. But soon enough, each of us put their ideas forward and the big picture started to seem a bit clearer. From then onwards, I have come to realise that group discussions are of vital importance when it comes to understanding a new concept, which has only made the project run smoother. In my personal opinion, I have been able to complete the delegated tasks on time and also have been assisting others when needed. However, in the later parts of the project I feel as if I could have done more work besides graphics development and formulation of helper functions, which would have enabled us to improve our extension further. If we were to do the same project in the future, I would contribute a bit more in the later parts and reduce some burden off Harjuno's shoulders, who has proven himself to be an epitome of a good leader.
\subsection{Szymon}
Based on my WEBPA feedback, I can tell that my group members have had quite positive experience in working with me. I happen to believe the same about them. I think we created a well-oiled team that was capable of helping each other with problems as well as stimulating and requiring hard work. This team expierence has definitely developed my skills of communicating with others and taught me how to efficiently divide work between team members. This team experience has definitely developed my skills of communicating with others and taught me how to efficiently divide work between team members.
\end{document}
